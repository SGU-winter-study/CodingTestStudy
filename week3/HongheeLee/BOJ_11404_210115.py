'''
    문제설명
        백준 11404 (플로이드 와샬 알고리즘 이용)
        모든 도시의 쌍 (A, B)에 대해서 A에서 B로 가는데 필요한 비용의 최솟값을 구하라.
    해결전략
        최단경로를 구하는 알고리즘은 크게 다익스트라 알고리즘과 플로이드 알고리즘이 있다.
        한 정점에서의 최단경로를 구할 떄는 다익스트라를 이용하고 모든 정점 쌍에 대해 최단경로를 구할 때는 플로이드를 이용한다.
        플로이드 와샬 알고리즘의 시간복잡도는 O(N^3)이다.
        2차원 리스트 dis에서 dis[i][j]는 i에서 j까지 가는데 드는 최소비용이다. 처음에는 모든 원소를 가능한 최대 비용으로 초기화한다.
        그 이후에 자기 자신으로 가는 비용은 0이므로 dis[i][i]를 0으로 초기화한다.
        그리고 버스 노선 정보를 차례로 읽으며 그래프 인접행렬을 초기화하듯이 도시 사이의 연결관계와 간선의 가중치를 표시한다. 
        두 노드 사이의 간선은 두 개 이상일 수 있지만 최소비용을 구하는 경우에는 가중치가 작은 간선만 이용하므로 그 값으로 초기화한다.
        플로이드 알고리즘은 거쳐가는 노드, 시작 노드, 도착 노드의 순으로 3중 for문을 이용한다.
        i에서 j로 가는데 기존 방식과 k를 거쳐서 가는 방식을 비교해서 더 비용이 적은 방법을 선택해서 dis 리스트의 값을 갱신한다.
        따라서 기존 인접행렬과 유사한 dis 리스트를 도시 1을 거쳐 갈 때로 갱신하고, 도시 2를 거쳐갈 때로 갱신하고 이렇게 차례로 적용한다.
        출력할 때는 i에서 j로 갈 수 없는 경우 dis[i][j] 값이 처음 초기화된 값 INF에서 변하지 않았을 것이므로 0으로 출력하고 나머지는 dis[i][j] 값을 출력한다.
'''
import sys
INF = 100000 * 100
n = int(sys.stdin.readline())
m = int(sys.stdin.readline())
dis = [[INF]*(n+1) for _ in range(n+1)]
for i in range(1, n+1):
    dis[i][i] = 0
for i in range(m):
    a, b, c = map(int, sys.stdin.readline().split())
    dis[a][b] = min(dis[a][b], c)
for k in range(1, n+1):
    for i in range(1, n+1):
        for j in range(1, n+1):
            dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])
for i in range(1, n+1):
    for j in range(1, n+1):
        if dis[i][j] == INF:
            print(0, end=' ')
        else:
            print(dis[i][j], end = ' ')
    print()
